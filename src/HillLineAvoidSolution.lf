target C {
  platform: {
    name: "rp2040",
    board: "pololu_3pi_2040_robot"
  },
  threading: false,
}

import Line from "lib/Line.lf"
import Display from "lib/Display.lf"
import Motors from "lib/Motors.lf"
import Encoders from "lib/Encoders.lf"
import GyroAngle from "lib/IMU.lf"



reactor Robot {
  input move:bool
  input turn_r:bool
  input turn_l:bool
  input back:bool



  output left_pwr:float
  output right_pwr:float

  mode LEFT {
    reaction(turn_l) -> DRIVING, left_pwr, right_pwr {=
      if(!turn_l->value) {
        lf_set_mode(DRIVING);
        lf_set(left_pwr, 0.15f);
        lf_set(right_pwr, 0.15f);
      }
    =}
  }

  mode RIGHT {
    reaction(turn_r) -> DRIVING, left_pwr, right_pwr {=
      if(!turn_r->value) {
        lf_set_mode(DRIVING);
        lf_set(left_pwr, 0.15f);
        lf_set(right_pwr, 0.15f);
      }
    =}
  }

  mode REVERSE {
    reaction(back) -> DRIVING, left_pwr, right_pwr {=
      if(!back->value) {
        lf_set_mode(DRIVING);
        lf_set(left_pwr, 0.15f);
        lf_set(right_pwr, 0.15f);
      }
    =}
  }

  initial mode DRIVING {
    reaction(move, turn_r, turn_l, back) -> RIGHT, LEFT, REVERSE, left_pwr, right_pwr {=
      // printf("Inside turn reaction of driviing");
      if(move->value){
        lf_set(left_pwr, 0.15f);
        lf_set(right_pwr, 0.15f);
      }
      if(turn_r->value){
        lf_set_mode(RIGHT);
        lf_set(left_pwr, 0.0f);
        lf_set(right_pwr, -0.15f);
      }
      if(turn_l->value){
        lf_set_mode(RIGHT);
        lf_set(left_pwr, -0.15f);
        lf_set(right_pwr, 0.0f);
      }
      if(back->value){
        lf_set_mode(REVERSE);
        lf_set(left_pwr, -0.10f);
        lf_set(right_pwr, -0.15f);
      }
    =}
  }
}



main reactor(calibration_time: time = 10 s, sample_period: time = 100 ms) {
  line = new Line()
  disp = new Display()
  robot = new Robot()
  m = new Motors()
  // dist = new AngleToDistance()
  gyro = new GyroAngle()
  encoder = new Encoders()

  timer t(0, sample_period)
  // Timer used to display seconds.
  timer seconds(0, 1 s)
  timer end_calibration(calibration_time)
  state count: int = 0

  preamble {=
  #include <stdio.h>
  #include <pico/stdlib.h>
  #include <hardware/gpio.h>
  #define THRESH 450
=}

  reaction(startup) -> disp.line0, disp.line1, disp.line2 {=
    lf_set(disp.line0, "CALIBRATING");
    lf_set(disp.line1, "Roll robot over");
    lf_set(disp.line2, "light and dark.");

  =}

  reaction(seconds) -> disp.line3 {=
    static char buf[17];
    snprintf(buf, 17, "time:%8d s", self->count++);
    lf_set(disp.line3, buf);
  =}

  reaction(end_calibration) -> line.calibrate{=
    lf_set(line.calibrate, false);

  =}

  reaction(t) -> encoder.trigger, gyro.trigger, line.trigger {=
    lf_set(encoder.trigger, true);
    lf_set(gyro.trigger, true);
    lf_set(line.trigger, true);
  =}

  reaction(line.reflect) -> robot.turn_r, robot.move, robot.back, robot.turn_l, disp.line0, disp.line1, disp.line2 {=
    static char buf0[17];
    static char buf1[17];
    static char buf2[17];



    lf_set(robot.move, true);



    if(line.reflect->value[0]> THRESH && line.reflect->value[1] > THRESH) {
      // snprintf(buf0, 17, "Turn R");
      lf_set(robot.turn_r, true);



    }
    else{
      lf_set(robot.turn_r, false);
    }

    if (line.reflect->value[1] > THRESH && line.reflect->value[2] > THRESH && line.reflect->value[3] > THRESH) {
      // snprintf(buf0, 17, "BACK");
      lf_set(robot.back, true);

    }
    else{
      lf_set(robot.back, false);
    }


    if(line.reflect->value[3]> THRESH && line.reflect->value[4] > THRESH) {
      // snprintf(buf0, 17, "Turn L");
      lf_set(robot.turn_l, true);

    }
    else{
      lf_set(robot.turn_l, false);
    }

    lf_set(disp.line0, buf0);
    lf_set(disp.line1, buf1);
    lf_set(disp.line2, buf2);

  =}


robot.left_pwr -> m.left_power;
robot.right_pwr -> m.right_power;

}
